{"ast":null,"code":"import { solution, unicodeSplit } from './words';\n\nfunction convertLetterToNumber(str) {\n  let out = 0,\n      len,\n      pos;\n  len = str.length;\n\n  for (pos = 0; pos < len; pos++) {\n    out += (str.charCodeAt(pos) - 64) * Math.pow(26, len - pos - 1);\n  }\n\n  return out;\n}\n\nexport const getStatuses = guesses => {\n  const charObj = {};\n  const splitSolution = unicodeSplit(solution);\n  guesses.forEach(word => {\n    unicodeSplit(word).forEach((letter, i) => {\n      if (letter === splitSolution[i]) {\n        //make status correct\n        return charObj[letter] = 'correct';\n      }\n\n      if (charObj[letter] !== 'correct' || charObj[letter] !== 'far1') {\n        //make status close1\n        return charObj[letter] = 'close1';\n      }\n\n      if (charObj[letter] !== 'correct' || charObj[letter] !== 'close1') {\n        //make status close1\n        return charObj[letter] = 'far1';\n      }\n    });\n  });\n  return charObj;\n};\nexport const getGuessStatuses = guess => {\n  const splitSolution = unicodeSplit(solution);\n  const splitGuess = unicodeSplit(guess);\n  const solutionCharsTaken = splitSolution.map(_ => false);\n  const statuses = Array.from(Array(guess.length)); // handle all correct cases first\n\n  splitGuess.forEach((letter, i) => {\n    if (letter === splitSolution[i]) {\n      statuses[i] = 'correct';\n      solutionCharsTaken[i] = true;\n      return;\n    }\n  }); // Close: 1 letter\n\n  splitGuess.forEach((letter, i) => {\n    if (Math.abs(convertLetterToNumber(letter) - convertLetterToNumber(splitSolution[i])) <= 1 && Math.abs(convertLetterToNumber(letter) - convertLetterToNumber(splitSolution[i])) != 0) {\n      statuses[i] = 'close1';\n      return;\n    }\n  }); // Far: 10 letters\n\n  splitGuess.forEach((letter, i) => {\n    if (Math.abs(convertLetterToNumber(letter) - convertLetterToNumber(splitSolution[i])) > 10 && Math.abs(convertLetterToNumber(letter) - convertLetterToNumber(splitSolution[i])) != 0) {\n      statuses[i] = 'far1';\n      return;\n    }\n  });\n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return;\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent';\n      return;\n    } // now we are left with \"present\"s\n\n\n    const indexOfPresentChar = splitSolution.findIndex((x, index) => x === letter && !solutionCharsTaken[index]);\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'here';\n      solutionCharsTaken[indexOfPresentChar] = true;\n      return;\n    } else {\n      statuses[i] = 'absent';\n      return;\n    }\n  });\n  return statuses;\n};","map":{"version":3,"sources":["/Users/abdirahman/proximle/react-wordle/src/lib/statuses.ts"],"names":["solution","unicodeSplit","convertLetterToNumber","str","out","len","pos","length","charCodeAt","Math","pow","getStatuses","guesses","charObj","splitSolution","forEach","word","letter","i","getGuessStatuses","guess","splitGuess","solutionCharsTaken","map","_","statuses","Array","from","abs","includes","indexOfPresentChar","findIndex","x","index"],"mappings":"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","sourcesContent":["import { solution, unicodeSplit } from './words'\n\nexport type CharStatus = 'absent' | 'here' | 'correct' | 'close1' | 'far1'\n\nfunction convertLetterToNumber(str:string) {\n  let out = 0,\n  len:number,\n  pos:number\n    len = str.length;\n  for (pos = 0; pos < len; pos++) {\n    out += (str.charCodeAt(pos) - 64) * Math.pow(26, len - pos - 1);\n  }\n  return out;\n}\nexport const getStatuses = (\n  guesses: string[]\n): { [key: string]: CharStatus } => {\n  const charObj: { [key: string]: CharStatus } = {}\n  const splitSolution = unicodeSplit(solution)\n\n  guesses.forEach((word) => {\n    unicodeSplit(word).forEach((letter, i) => {\n\n      if (letter === splitSolution[i]) {\n        //make status correct\n        return (charObj[letter] = 'correct')\n      }\n\n      if (charObj[letter] !== 'correct' || charObj[letter] !== 'far1') {\n        //make status close1\n        return (charObj[letter] = 'close1')\n      }\n\n      if (charObj[letter] !== 'correct' || charObj[letter] !== 'close1') {\n        //make status close1\n        return (charObj[letter] = 'far1')\n      }\n    })\n  })\n\n  return charObj\n}\n\nexport const getGuessStatuses = (guess: string): CharStatus[] => {\n  const splitSolution = unicodeSplit(solution)\n  const splitGuess = unicodeSplit(guess)\n\n  const solutionCharsTaken = splitSolution.map((_) => false)\n\n  const statuses: CharStatus[] = Array.from(Array(guess.length))\n\n  // handle all correct cases first\n  splitGuess.forEach((letter, i) => {\n    if (letter === splitSolution[i]) {\n      statuses[i] = 'correct'\n      solutionCharsTaken[i] = true\n      return\n    }\n  })\n\n  // Close: 1 letter\n\n    splitGuess.forEach((letter, i) => {\n    if (\n    Math.abs(\n      convertLetterToNumber(letter) -\n        convertLetterToNumber(splitSolution[i])\n    ) <= 1 && Math.abs(\n      convertLetterToNumber(letter) -\n        convertLetterToNumber(splitSolution[i])\n    ) != 0) {\n      statuses[i] = 'close1'\n      return\n    } \n  })\n\n   // Far: 10 letters\n\n    splitGuess.forEach((letter, i) => {\n    if (\n    Math.abs(\n      convertLetterToNumber(letter) -\n        convertLetterToNumber(splitSolution[i])\n    ) > 10 && Math.abs(\n      convertLetterToNumber(letter) -\n        convertLetterToNumber(splitSolution[i])\n    ) != 0) {\n      statuses[i] = 'far1'\n      return\n    } \n  })\n  \n  splitGuess.forEach((letter, i) => {\n    if (statuses[i]) return\n\n    if (!splitSolution.includes(letter)) {\n      // handles the absent case\n      statuses[i] = 'absent'\n      return\n    }\n\n    // now we are left with \"present\"s\n    const indexOfPresentChar = splitSolution.findIndex(\n      (x, index) => x === letter && !solutionCharsTaken[index]\n    )\n\n    if (indexOfPresentChar > -1) {\n      statuses[i] = 'here'\n      solutionCharsTaken[indexOfPresentChar] = true\n      return\n    } else {\n      statuses[i] = 'absent'\n      return\n    }\n  })\n\n  return statuses\n}\n"]},"metadata":{},"sourceType":"module"}